; kate: syntax Intel x86 (NASM);

; Copyright (C) 2009 Amand "alrj" Tihon <amand.tihon@alrj.org>

; Import by hash for linux/amd64 (elf64-x86-64)
; This file is part of bold, the Byte Optimized Linker.

; You can redistribute this file and/or modify it under the terms of the
; GNU General Public License as published by the Free Software Foundation,
; either version 3 of the License or (at your option) any later version.

; Under Section 7 of GPL version 3, you are granted additional
; permissions described in the Bold Runtime Library Exception, version
; 1.0, as published by Amand Tihon.

;------------------------------------------------------------------------------
; alrj's x86_64 version of the import by hash method by parapete, las, leblane.
; See the wonderful thread at http://www.pouet.net/topic.php?which=5392 to
; learn everything about import by hash on Linux.

; Compile with
; nasm -f elf64 -o bold_ibh-x86_64.o bold_ibh-x86_64.asm


BITS 64
CPU X64

global _bold__ibh_start
global exit

extern _dt_debug                        ; defined by bold linker
extern _bold__functions_hash            ; in .data, generated by bold
extern _bold__functions_pointers        ; in .bss, generated by bold
extern _bold__functions_count           ; immediate 32 bits
extern main                             ; must be declared when using this

%define SYS_exit      60
%define DT_HASH       4

segment .text

_bold__ibh_start:
; {{{ Do the RTLD
  mov r14, [rel _dt_debug]              ; r14 points to r_debug
  mov r14, [r14 + 8]                    ; r14 points to link_map
  mov r14, [r14 + 24]                   ; skip the first two link_map entries
  mov r14, [r14 + 24]

  mov esi, _bold__functions_hash        ; Implicitly zero-extended
  mov edi, _bold__functions_pointers    ; ditto
  push byte _bold__functions_count      ; Warning: Max 127 external symbols.
  pop rcx                               ;  Linker should enforce this.

  ; Load all the symbols
  .symbol_loop:
    lodsd                                 ; Load symbol hash
    xchg ebx, eax                         ; into ebx
    push rsi
    push rcx

;   {{{ For each hash

    ; Iterate over libraries found in link_map
    .libloop:
      mov rdx, [r14 + 16]                 ; link_map->l_ld

      ; Find the interesting entries in the DYNAMIC table.
      .dynamic_loop:

        push byte DT_HASH                 ; DT_HASH == 4
        pop rax
        cmp [rdx], eax
        cmove r9, [rdx+8]                 ; r9 : pointer to the hash table

        inc eax                           ; DT_STRTAB == 5
        cmp [rdx], eax
        cmove r10, [rdx+8]                ; r10 : pointer to strtab

        inc eax                           ; DT_SYMTAB == 6
        cmp [rdx], eax
        cmove r11, [rdx+8]                ; r11 : pointer to symtab

        ; Next dynamic entry
        lea rdx, [rdx + 16]               ; add rdx, 16
        xor eax, eax
        cmp [rdx], eax
        jnz short .dynamic_loop

      ; All DYNAMIC entries have been read.
      mov ecx, [r9 + 4]                   ; nchain, number of exported symbols

      ; Iterate over the symbols in the library (symtab entries).
      .symbolloop:
        ; Find the symbol name in strtab
        mov esi, [r11]                    ; st_name, offset in strtab
        add rsi, r10                      ; pointer to symbol name

        ; Compute the hash
        xor edx, edx
        xor eax, eax
        .hash_loop:                       ; over each char
          imul edx, edx, byte 0x21
          xor edx, eax
          lodsb
          test al, al
          jnz short .hash_loop

        .hash_end:
        cmp edx, ebx                      ; Compare with stored hash
        je short .found
        lea r11, [r11 + 24]               ; Next symtab entry
      loop .symbolloop

      ; Symbol was not found in this library
      mov r14, [r14 + 24]                 ; Next link_map entry
      jmp short .libloop
    .found:
    mov rax, [r11 + 8]                    ; st_value, offset of the symbol
    add rax, [r14]                        ; add link_map->l_addr
    stosq                                 ; Store function pointer
;   }}}

    pop rcx
    pop rsi
    loop .symbol_loop
; }}}

  ; When all is resolved, call main()
  call main
  xchg edi, eax

exit:
  ; Exit cleanly
  push byte SYS_exit
  pop rax
  syscall

%assign code_size $ - _bold__ibh_start
%warning "Code size is:" code_size
