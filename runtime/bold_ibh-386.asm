; kate: syntax Intel x86 (NASM);

; Copyright (C) 2009 Amand "alrj" Tihon <amand.tihon@alrj.org>

; Import by hash for linux/amd64 (elf64-x86-64)
; This file is part of bold, the Byte Optimized Linker.

; You can redistribute this file and/or modify it under the terms of the
; GNU General Public License as published by the Free Software Foundation,
; either version 3 of the License or (at your option) any later version.

; Under Section 7 of GPL version 3, you are granted additional
; permissions described in the Bold Runtime Library Exception, version
; 1.0, as published by Amand Tihon.

;------------------------------------------------------------------------------
; alrj's x86_64 version of the import by hash method by parapete, las, leblane.
; See the wonderful thread at http://www.pouet.net/topic.php?which=5392 to
; learn everything about import by hash on Linux.

; Compile with
; yasm -f elf64 -o bold_ibh-x86_64.o bold_ibh-x86_64.asm
; (or replace yasm by nasm)

BITS 32

global _bold__ibh_start
global exit

extern _dt_debug                        ; defined by bold linker
extern _bold__functions_hash            ; in .data, generated by bold
extern _bold__functions_pointers        ; in .bss, generated by bold
extern _bold__functions_count           ; immediate 32 bits
extern main                             ; must be declared when using this

%define SYS_exit      60
%define DT_HASH       4

segment .text

_bold__ibh_start:
    enter 20, 0
; {{{ Do the RTLD
  mov ebx, [_dt_debug]                  ; rbx points to r_debug
  mov ebx, [ebx + 4]                    ; rbx points to link_map
  mov ebx, [ebx + 12]                   ; skip the first two link_map entries
  mov ebx, [ebx + 12]

  mov esi, _bold__functions_hash        ; Implicitly zero-extended
  mov edi, _bold__functions_pointers    ; ditto
  mov ecx, _bold__functions_count

  ; Load all the symbols
  .symbol_loop:
    lodsd                               ; Load symbol hash in eax
    pusha
    call get_symbol
    mov DWORD [esp+28], eax
    popa
    stosd
    loop .symbol_loop

  call main
  mov edi, eax

exit:
  ; Exit cleanly
  ;mov eax, SYS_exit
  ;syscall
  xor eax, eax
  inc eax
  int 0x80


get_dynamic_entry:
.loop0:
    cmp [esi], edi
    jz .found
    add esi, 8
    jmp .loop0
.found:
    mov esi, [esi+4]
    ret

;   {{{ For each hash
get_symbol:
    enter 8, 0
    mov [ebp-8], eax                    ; save function hash
    ;mov r13, ebx                          ; copy link_map's pseudo-head

    ; Iterate over libraries found in link_map
    .libloop:
        test ebx, ebx
        jz .found
        mov [ebp-4], ebx

        ; Find the interesting entries in the DYNAMIC table.
        mov eax, [ebx+8] ; link_map->l_ld
        mov esi, eax
        mov edi, 5
        call get_dynamic_entry
        mov ebx, esi
        mov esi, eax
        mov edi, 6
        call get_dynamic_entry
        mov edx, esi
        mov esi, eax
        mov edi, 4
        call get_dynamic_entry
        mov ecx, [esi+4]


      ; All DYNAMIC entries have been read.
      ;mov ecx, [r9 + 4]                   ; nchain, number of exported symbols

      ; Iterate over the symbols in the library (symtab entries).
      .symbolloop:
        ; Find the symbol name in strtab
        mov esi, [edx]                    ; st_name, offset in strtab
        add esi, ebx                      ; pointer to symbol name

        ; Compute the hash
        xor edi, edi
        xor eax, eax
        .hash_loop:                       ; over each char
          imul edi, edi, byte 0x21
          xor edi, eax
          lodsb
          test al, al
          jnz short .hash_loop

        .hash_end:
        cmp edi, [ebp-8]                     ; Compare with stored hash
        je .found
        add edx, 16                       ; Next symtab entry
      loop .symbolloop

      ; Symbol was not found in this library
      mov ebx, [ebp - 4]                 ; Next link_map entry
      mov ebx, [ebx + 12]
      jmp short .libloop
    .found:
    mov eax, [edx + 4]                    ; st_value, offset of the symbol
    mov ebx, [ebp - 4]
    add eax, [ebx]                        ; add link_map->l_addr
;   }}}
    leave
    ret

    ;pop ecx
    ;pop esi
    ;stosq                               ; Store function pointer
    ;loop .symbol_loop
; }}}

  ; When all is resolved, call main()
  ;call main
  ;mov edi, eax

;exit:
  ;; Exit cleanly
  ;mov eax, SYS_exit
  ;syscall
